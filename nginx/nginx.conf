worker_processes auto;
error_log /var/log/nginx/error.log info;
pid /var/run/nginx.pid;

# Export environment variables to Lua
env REDIS_HOST;
env REDIS_PORT;
env MODEL_URL;
env MODEL_NAME;
env MODEL_GGUF_PATH;
env MODEL_TEMPERATURE;
env MODEL_TOP_P;
env MODEL_TOP_K;
env MODEL_MIN_P;
env MODEL_NUM_CTX;
env MODEL_NUM_PREDICT;
env MODEL_REPEAT_PENALTY;
env MODEL_REPEAT_LAST_N;
env MODEL_SEED;
env OLLAMA_GPU_LAYERS;
env OLLAMA_NUM_THREAD;
env OLLAMA_KEEP_ALIVE;
env DEBUG_MODE;

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # DNS resolver for Docker services
    resolver 127.0.0.11 valid=30s ipv6=off;
    resolver_timeout 30s;

    # ENHANCED: File upload settings for large files
    client_max_body_size 100M;
    client_body_buffer_size 1M;
    client_body_timeout 300s;
    client_header_timeout 60s;
    send_timeout 0; # No timeout for sending to client
    
    # Create temp directory for large uploads
    client_body_temp_path /tmp/nginx_uploads;

    # CRITICAL: No timeouts for AI streaming responses - FIXED
    sendfile off;
    tcp_nopush off;
    tcp_nodelay on;
    keepalive_timeout 0;  # No timeout for keep-alive
    
    # CRITICAL: Disable all buffering for real-time AI streaming
    proxy_buffering off;
    proxy_request_buffering on;
    proxy_http_version 1.1;
    proxy_read_timeout 0;     # No timeout for reading AI responses
    proxy_send_timeout 0;     # No timeout for sending to AI
    proxy_connect_timeout 30s; # Only connection timeout
    
    # Lua package path for modular structure
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;;";
    
    # CRITICAL: Lua timeouts set to unlimited for AI responses - FIXED
    lua_socket_read_timeout 0;      # No timeout for AI responses
    lua_socket_send_timeout 0;      # No timeout for sending
    lua_socket_connect_timeout 60s; # Longer connection timeout for Ollama startup
    lua_socket_keepalive_timeout 60s; # Keep connections alive longer

    # Shared memory for application state
    lua_shared_dict startup_time 1m;
    
    # Initialize startup time
    init_by_lua_block {
        ngx.shared.startup_time:set("start", ngx.time())
    }

    server {
        listen 443;
        server_name localhost;
        
        # Security headers for all responses
        add_header X-Frame-Options "DENY" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # Chat page (root path)
        location = / {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.serve_chat_page()
            }
        }

        # Static assets with caching
        location /static/ {
            root /usr/local/openresty/nginx;
            expires 1h;
            add_header Cache-Control "public, immutable";
            
            try_files $uri @static_fallback;
        }
        
        location @static_fallback {
            content_by_lua_block {
                local chat_view = require "chat_view"
                chat_view.serve_static_file(ngx.var.uri)
            }
        }

        # API Routes

        # Create new chat endpoint
        location = /api/chat/create {
            lua_need_request_body on;
            
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_create_chat()
            }
        }

        # CRITICAL: Chat streaming endpoint with UNLIMITED timeouts - FIXED
        location = /api/chat/stream {
            lua_need_request_body on;
            
            # CRITICAL: Set ALL timeouts to unlimited for complete AI responses
            lua_socket_read_timeout 0;      # No timeout for reading from Ollama
            lua_socket_send_timeout 0;      # No timeout for sending to Ollama  
            lua_socket_connect_timeout 120s; # Generous connection timeout for Ollama
            lua_socket_keepalive_timeout 300s; # Keep connections alive longer
            proxy_read_timeout 0;           # No timeout for proxy reads
            proxy_send_timeout 0;           # No timeout for proxy sends
            proxy_connect_timeout 120s;     # Generous proxy connection timeout
            
            # Disable ALL buffering for real-time streaming
            proxy_buffering off;
            proxy_request_buffering off;
            add_header X-Accel-Buffering no;
            
            # No additional client timeouts needed here - set in http block
            
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_chat_stream()
            }
        }

        # NEW: Chat continuation endpoint for incomplete responses - FIXED
        location = /api/chat/continue {
            lua_need_request_body on;
            
            # Same unlimited timeout settings as streaming
            lua_socket_read_timeout 0;
            lua_socket_send_timeout 0;
            lua_socket_connect_timeout 120s;
            lua_socket_keepalive_timeout 300s;
            proxy_read_timeout 0;
            proxy_send_timeout 0;
            proxy_connect_timeout 120s;
            proxy_buffering off;
            proxy_request_buffering off;
            add_header X-Accel-Buffering no;
            
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_chat_continuation()
            }
        }

        # Chat history endpoint
        location = /api/chat/history {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_chat_history()
            }
        }

        # Chat list endpoint
        location = /api/chat/list {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_chat_list()
            }
        }

        # Clear specific chat endpoint
        location = /api/chat/clear {
            lua_need_request_body on;
            
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_clear_chat()
            }
        }

        # Delete specific chat endpoint
        location = /api/chat/delete {
            lua_need_request_body on;
            
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_delete_chat()
            }
        }

        # Delete all chats endpoint
        location = /api/chat/delete-all {
            lua_need_request_body on;
            
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_delete_all_chats()
            }
        }

        # Get message details including artifacts
        location = /api/message/details {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_message_details()
            }
        }

        # Get all artifacts for a chat
        location = /api/chat/artifacts {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_chat_artifacts()
            }
        }

        # Export artifacts endpoint
        location = /api/chat/export {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_export_artifacts()
            }
        }

        # Health check endpoint
        location = /api/health {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_health_check()
            }
        }

        # API documentation
        location = /api/docs {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_api_docs()
            }
        }

        # System status page
        location = /status {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_status()
            }
        }

        # Maintenance endpoint (for admin use)
        location = /maintenance {
            access_log off;
            content_by_lua_block {
                local chat_view = require "chat_view"
                chat_view.render_maintenance_page("System is under maintenance", "300")
            }
        }

        # Robots.txt
        location = /robots.txt {
            content_by_lua_block {
                ngx.header["Content-Type"] = "text/plain"
                ngx.say("User-agent: *")
                ngx.say("Disallow: /api/")
                ngx.say("Disallow: /static/")
                ngx.say("Allow: /")
            }
        }

        # Error handling with custom pages
        error_page 404 @not_found;
        error_page 500 502 503 504 @server_error;

        location @not_found {
            internal;
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_not_found()
            }
        }

        location @server_error {
            internal;
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_error("Internal server error", ngx.status)
            }
        }

        # Catch-all for undefined routes
        location / {
            content_by_lua_block {
                local chat_handler = require "chat_handler"
                chat_handler.handle_not_found()
            }
        }
    }
}